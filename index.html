<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game - Enemies & Falling Platforms</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { background-color: #87CEEB; display: block; margin: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game settings
        const gravity = 0.5;
        const friction = 0.8;
        const baseJump = -12;
        const platformFallDelay = 4;
        const platformFallSpeed = 2;
        const enemyChance = 0.05; // 5% chance for a platform to have an enemy

        // Player
        let player = {
            x: canvas.width / 2 - 10,
            y: canvas.height - 20,
            width: 20,
            height: 20,
            speed: 5,
            velX: 0,
            velY: 0,
            jumping: false,
            currentPlatform: null,
            onGround: true
        };

        // Enemy settings
        const enemyWidth = 15;
        const enemyHeight = 15;
        const enemyType2Speed = 1;

        // Platforms & Global Counter
        let platforms = [];
        let platformCounter = 0;
        const platformWidth = 100;
        const platformHeight = 10;
        const initialPlatformMaxHeight = 90;
        const platformMinSpacing = 80;
        const platformMaxSpacing = 150;

        // --- Enemy Creation Function ---
        function createEnemy(platform) {
            let enemyType = (Math.random() < 0.5) ? 'type1' : 'type2'; // 50% chance for each type
            let enemy = {
                width: enemyWidth,
                height: enemyHeight,
                type: enemyType,
                // Start enemy in the middle of the platform
                x: platform.x + (platform.width / 2) - (enemyWidth / 2),
                y: platform.y - enemyHeight,
                // Type 2 specific properties
                direction: (enemyType === 'type2') ? 1 : 0, // 1 for right, -1 for left, 0 for static
                speed: (enemyType === 'type2') ? enemyType2Speed : 0
            };
            return enemy;
        }

        // --- Initial Platform & Enemy Generation ---
        platformCounter++;
        let firstPlatformY = player.y - (Math.random() * (initialPlatformMaxHeight - platformHeight) + platformHeight + 10);
        let firstPlatform = {
            x: Math.random() * (canvas.width - platformWidth),
            y: firstPlatformY,
            width: platformWidth,
            height: platformHeight,
            standTimer: 0,
            isFalling: false,
            isPlayerOn: false,
            labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
            enemy: null // Initialize enemy as null
        };
        // Check if the first platform gets an enemy
        if (Math.random() < enemyChance) {
            firstPlatform.enemy = createEnemy(firstPlatform);
        }
        platforms.push(firstPlatform);

        let lastPlatformY = firstPlatformY;
        for (let i = 1; i < 10; i++) {
            platformCounter++;
            let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
            let nextY = lastPlatformY - spacing;
            let newPlatform = {
                x: Math.random() * (canvas.width - platformWidth),
                y: nextY,
                width: platformWidth,
                height: platformHeight,
                standTimer: 0,
                isFalling: false,
                isPlayerOn: false,
                labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
                enemy: null // Initialize enemy as null
            };
            // Check if this platform gets an enemy
            if (Math.random() < enemyChance) {
                newPlatform.enemy = createEnemy(newPlatform);
            }
            platforms.push(newPlatform);
            lastPlatformY = nextY;
        }

        // Score Variables
        let score = 0;
        let highestYReached = canvas.height; // Start below ground for score trigger

        // Key Listener & Timing
        let keys = [];
        let lastFrameTime = performance.now();
        let gameRunning = true;

        window.addEventListener('keydown', function (e) {
            if (!gameRunning) return;
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping && (player.currentPlatform || player.onGround)) {
                player.jumping = true;
                player.onGround = false;
                player.velY = baseJump - Math.abs(player.velX * 0.1);
                if (player.currentPlatform) {
                    player.currentPlatform.isPlayerOn = false;
                    player.currentPlatform.standTimer = 0;
                    player.currentPlatform = null;
                }
            }
        });

        window.addEventListener('keyup', function (e) {
            if (!gameRunning) return;
            keys[e.keyCode] = false;
        });


        // --- Game Over Function ---
        function gameOver(reason) {
            if (!gameRunning) return; // Prevent multiple calls
            console.log("Game Over:", reason); // Log reason for debugging
            gameRunning = false;
             // Draw Game Over screen immediately on the current frame
             ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = 'white';
             ctx.font = '40px Arial';
             ctx.textAlign = 'center';
             ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
             ctx.font = '20px Arial';
             ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
             ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 50);
        }


        function updateGame() {
            if (!gameRunning) {
                // If game over was triggered last frame, stop requesting new frames
                return;
            }

            let now = performance.now();
            let deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            // --- Input & Movement ---
            if (keys[39]) { if (player.velX < player.speed) player.velX++; }
            else if (keys[37]) { if (player.velX > -player.speed) player.velX--; }
            else { player.velX *= friction; }

            player.velY += gravity;
            player.x += player.velX;
            player.y += player.velY;

            // --- Game Over Check (Falling Off Bottom) ---
            if (player.y >= canvas.height) {
                gameOver("Fell off screen");
                return; // Stop further updates this frame
            }

            // --- Platform & Enemy Logic ---
            platforms.forEach(platform => {
                // Update falling platforms
                if (platform.isFalling) {
                    platform.y += platformFallSpeed;
                    // Update enemy Y if it exists and platform is falling
                    if (platform.enemy) {
                        platform.enemy.y = platform.y - platform.enemy.height;
                    }
                }
                // Update standing timer and check for falling trigger
                else if (platform.isPlayerOn) {
                    platform.standTimer += deltaTime;
                    if (platform.standTimer >= platformFallDelay) {
                        platform.isFalling = true;
                        platform.isPlayerOn = false;
                        if (player.currentPlatform === platform) {
                            player.currentPlatform = null;
                        }
                    }
                } else {
                    platform.standTimer = 0; // Reset timer if player not on it
                }

                // --- Update Enemy Position ---
                if (platform.enemy && !platform.isFalling) {
                    let enemy = platform.enemy;
                    // Keep enemy Y position synced with platform
                    enemy.y = platform.y - enemy.height;

                    // Move Type 2 enemies
                    if (enemy.type === 'type2') {
                        enemy.x += enemy.speed * enemy.direction;
                        // Check for collision with platform edges
                        if (enemy.x <= platform.x || enemy.x + enemy.width >= platform.x + platform.width) {
                            enemy.direction *= -1; // Reverse direction
                            // Clamp position to prevent going slightly off-edge
                            enemy.x = Math.max(platform.x, Math.min(enemy.x, platform.x + platform.width - enemy.width));
                        }
                    }
                }
            });

            // --- Screen Scroll & Platform/Enemy Recycling ---
            let scrollOffset = 0;
            if (player.y < canvas.height / 4) {
                scrollOffset = Math.abs(player.velY) > 1 ? Math.abs(player.velY) : (canvas.height / 4 - player.y);
                if (scrollOffset < 0) scrollOffset = 0;

                player.y += scrollOffset;
                highestYReached += scrollOffset;

                platforms.forEach(platform => {
                    platform.y += scrollOffset;
                    // Sync enemy Y during scroll if it exists
                    if (platform.enemy) {
                        platform.enemy.y = platform.y - platform.enemy.height;
                    }

                    if (platform.y > canvas.height) { // If platform off-screen bottom
                        // Reset state
                        platform.isFalling = false;
                        platform.standTimer = 0;
                        platform.isPlayerOn = false;
                        platform.enemy = null; // Remove existing enemy

                        // Assign new label number
                        platformCounter++;
                        platform.labelNumber = (platformCounter % 10 === 0) ? platformCounter : null;

                        // Chance to add a new enemy
                        if (Math.random() < enemyChance) {
                            platform.enemy = createEnemy(platform); // Create new enemy *after* positioning platform
                        }

                        // Reposition platform above highest visible platform
                        let topPlatformY = Math.min(...platforms.map(p => p.y).filter(y => y > -Infinity && y < canvas.height));
                        if (topPlatformY === Infinity) {
                            topPlatformY = player.y - canvas.height / 2;
                        }
                        let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                        platform.y = topPlatformY - spacing;
                        platform.x = Math.random() * (canvas.width - platform.width);

                        // Re-position enemy if just added to the newly positioned platform
                         if (platform.enemy) {
                             platform.enemy.x = platform.x + (platform.width / 2) - (platform.enemy.width / 2);
                             platform.enemy.y = platform.y - platform.enemy.height;
                         }
                    }
                });
            }

            // --- Collision Detection ---
            // Horizontal Edge Collision
            if (player.x >= canvas.width - player.width) { player.x = canvas.width - player.width; player.velX = 0; }
            else if (player.x <= 0) { player.x = 0; player.velX = 0; }

            let onPlatformThisFrame = null;
            let onGroundThisFrame = false;

            // Ground Collision Check
            if (player.y >= canvas.height - player.height) {
                player.y = canvas.height - player.height;
                if (player.velY > 0) {
                     player.velY = 0;
                     player.jumping = false;
                     onGroundThisFrame = true;
                }
            }

            // Platform & Enemy Collision
            platforms.forEach(platform => {
                // --- Player vs Enemy Collision ---
                if (platform.enemy && !platform.isFalling) {
                    let enemy = platform.enemy;
                    // Simple AABB collision check
                    if (
                        player.x < enemy.x + enemy.width &&
                        player.x + player.width > enemy.x &&
                        player.y < enemy.y + enemy.height &&
                        player.y + player.height > enemy.y
                    ) {
                        gameOver("Hit enemy");
                        return; // Exit loop and update function early
                    }
                }

                // --- Player vs Platform Collision ---
                if (!platform.isFalling && !onPlatformThisFrame) { // Check platform only if not already landed and platform not falling
                    if (
                        player.velY >= 0 &&
                        player.x < platform.x + platform.width &&
                        player.x + player.width > platform.x &&
                        player.y + player.height >= platform.y &&
                        player.y + player.height <= platform.y + platform.height + Math.max(1, player.velY)
                    ) {
                        // Score calculation
                        let landingY = platform.y - player.height;
                        if (landingY < highestYReached) {
                            let heightGain = Math.round(highestYReached - landingY);
                            score += heightGain; score += Math.round(heightGain * 0.1);
                            highestYReached = landingY;
                        }
                        // Landing physics
                        player.jumping = false; player.velY = 0;
                        player.y = platform.y - player.height;
                        onPlatformThisFrame = platform;
                        onGroundThisFrame = false;
                    }
                }
            });
             if (!gameRunning) return; // Check again if game over was triggered by enemy collision

            // --- Update Player's Platform/Ground Status ---
            player.onGround = onGroundThisFrame;

            if (onPlatformThisFrame && player.currentPlatform !== onPlatformThisFrame) {
                if (player.currentPlatform) { player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0; }
                player.currentPlatform = onPlatformThisFrame;
                player.currentPlatform.isPlayerOn = true; player.currentPlatform.standTimer = 0;
                player.onGround = false;
            }
            else if ((!onPlatformThisFrame && !onGroundThisFrame) && player.currentPlatform) {
                 player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                 player.currentPlatform = null;
            }
            else if (onGroundThisFrame && player.currentPlatform) {
                 player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                 player.currentPlatform = null;
            }

            // --- Drawing ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw platforms and enemies
            platforms.forEach(platform => {
                // Platform color
                if (platform.isPlayerOn && !platform.isFalling) ctx.fillStyle = '#555';
                else if (platform.isFalling) ctx.fillStyle = '#AAA';
                else ctx.fillStyle = 'black';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                // Platform Label
                if (platform.labelNumber !== null) {
                    ctx.fillStyle = 'white'; ctx.font = '10px Arial';
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(platform.labelNumber, platform.x + platform.width / 2, platform.y + platform.height / 2);
                }

                // Draw Enemy
                if (platform.enemy) {
                    let enemy = platform.enemy;
                    ctx.fillStyle = (enemy.type === 'type1') ? 'orange' : 'purple'; // Type1=Orange, Type2=Purple
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
            });

            // Draw Score
            ctx.fillStyle = 'black'; ctx.font = '20px Arial';
            ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
            ctx.fillText('Score: ' + score, 10, 30);

            // Request next frame
             requestAnimationFrame(updateGame); // Always request, the check at the start handles stopping
        }

        // Start the game loop
        updateGame();
    </script>
</body>
</html>