<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game - Enemies, Falling Platforms, Leaderboard</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { background-color: #87CEEB; display: block; margin: auto; cursor: default; } /* Default cursor */
        #gameCanvas.button-hover { cursor: pointer; } /* Pointer cursor when hovering button */
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Constants and Settings ---
        const gravity = 0.5;
        const friction = 0.8;
        const baseJump = -12;
        const platformFallDelay = 4;
        const platformFallSpeed = 2;
        const enemyChance = 0.05; // 5%
        const enemyWidth = 15;
        const enemyHeight = 15;
        const enemyType2Speed = 1;
        const platformWidth = 100;
        const platformHeight = 10;
        const initialPlatformMaxHeight = 90;
        const platformMinSpacing = 80;
        const platformMaxSpacing = 150;
        const leaderboardSize = 10;
        const localStorageKey = 'platformerTopScores';

        // --- Game State Variables ---
        let player;
        let platforms;
        let platformCounter;
        let score;
        let highestYReached;
        let keys = {}; // Initialize keys as an empty OBJECT
        let lastFrameTime = 0;
        let gameRunning = false;
        let topScores = [];

        // --- Button Definition ---
        const playAgainButton = {
            x: canvas.width / 2 - 75,
            y: canvas.height / 2 + 70,
            width: 150,
            height: 40
        };
        let isHoveringButton = false;

        // --- Helper Functions ---

        function loadScores() {
            const storedScores = localStorage.getItem(localStorageKey);
            if (storedScores) {
                try {
                    topScores = JSON.parse(storedScores);
                    if (!Array.isArray(topScores)) topScores = [];
                    topScores = topScores.map(Number).filter(Number.isFinite).sort((a, b) => b - a);
                } catch (e) {
                    console.error("Error parsing scores:", e); topScores = [];
                }
            } else { topScores = []; }
        }

        function saveScores() {
             if (typeof score === 'number' && isFinite(score)) {
                  topScores.push(score);
                  topScores.sort((a, b) => b - a);
                  topScores = topScores.slice(0, leaderboardSize);
                  localStorage.setItem(localStorageKey, JSON.stringify(topScores));
             } else {
                  console.warn("Invalid score, not saving:", score);
                  topScores.sort((a, b) => b - a);
                  localStorage.setItem(localStorageKey, JSON.stringify(topScores.slice(0, leaderboardSize)));
             }
        }

        // <<< Enemy Creation Function >>>
        function createEnemy(platform) {
            let enemyType = (Math.random() < 0.5) ? 'type1' : 'type2'; // 50% chance for each type
            let enemy = {
                width: enemyWidth,
                height: enemyHeight,
                type: enemyType,
                // Start enemy in the middle of the platform
                x: platform.x + (platform.width / 2) - (enemyWidth / 2),
                y: platform.y - enemyHeight,
                // Type 2 specific properties
                direction: (enemyType === 'type2') ? 1 : 0, // 1 for right, -1 for left, 0 for static
                speed: (enemyType === 'type2') ? enemyType2Speed : 0
            };
            return enemy;
        }

        // --- Game Initialization / Reset ---
        function resetGame() {
            console.log("Resetting game...");
            player = {
                x: canvas.width / 2 - 10, y: canvas.height - 20, // Start on ground
                width: 20, height: 20, speed: 5,
                velX: 0, velY: 0, jumping: false,
                currentPlatform: null, onGround: true // Start on ground
            };

            platforms = [];
            platformCounter = 0;

            // Initial Platform Generation (including potential enemies)
            platformCounter++;
            let firstPlatformY = player.y - (Math.random() * (initialPlatformMaxHeight - platformHeight) + platformHeight + 10);
            let firstPlatform = {
                x: Math.random() * (canvas.width - platformWidth), y: firstPlatformY,
                width: platformWidth, height: platformHeight, standTimer: 0,
                isFalling: false, isPlayerOn: false,
                labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
                enemy: null // <<< Initialize enemy property
            };
            // <<< Add enemy check for first platform >>>
            if (Math.random() < enemyChance) {
                firstPlatform.enemy = createEnemy(firstPlatform);
            }
            platforms.push(firstPlatform);

            let lastPlatformY = firstPlatformY;
            for (let i = 1; i < 10; i++) {
                platformCounter++;
                let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                let nextY = lastPlatformY - spacing;
                let newPlatform = {
                    x: Math.random() * (canvas.width - platformWidth), y: nextY,
                    width: platformWidth, height: platformHeight, standTimer: 0,
                    isFalling: false, isPlayerOn: false,
                    labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
                    enemy: null // <<< Initialize enemy property
                };
                // <<< Add enemy check for subsequent platforms >>>
                if (Math.random() < enemyChance) {
                    newPlatform.enemy = createEnemy(newPlatform);
                }
                platforms.push(newPlatform);
                lastPlatformY = nextY;
            }

            score = 0;
            highestYReached = canvas.height; // Reset score benchmark
            keys = {}; // Reset keys object
            lastFrameTime = performance.now();
            gameRunning = true; // Set game to running
        }

        // --- Game Over Handling ---
        function gameOver(reason) {
            if (!gameRunning) return;
            console.log("Game Over:", reason);
            gameRunning = false;
            saveScores();
        }

        // --- Drawing Functions ---
        function drawGame() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = 'red';
             ctx.fillRect(player.x, player.y, player.width, player.height);
             platforms.forEach(platform => {
                 if (platform.isPlayerOn && !platform.isFalling) ctx.fillStyle = '#555';
                 else if (platform.isFalling) ctx.fillStyle = '#AAA';
                 else ctx.fillStyle = 'black';
                 ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                 if (platform.labelNumber !== null) {
                     ctx.fillStyle = 'white'; ctx.font = '10px Arial';
                     ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                     ctx.fillText(platform.labelNumber, platform.x + platform.width / 2, platform.y + platform.height / 2);
                 }
                 // <<< Draw Enemy if it exists >>>
                 if (platform.enemy) {
                      ctx.fillStyle = (platform.enemy.type === 'type1') ? 'orange' : 'purple'; // Type1=Orange, Type2=Purple
                      ctx.fillRect(platform.enemy.x, platform.enemy.y, platform.enemy.width, platform.enemy.height);
                 }
             });
             ctx.fillStyle = 'black'; ctx.font = '20px Arial';
             ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
             ctx.fillText('Score: ' + score, 10, 30);
        }

        function drawGameOverScreen() {
             ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = 'white';
             ctx.font = '40px Arial'; ctx.textAlign = 'center';
             ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
             ctx.font = '20px Arial';
             ctx.fillText('Final Score: ' + (typeof score === 'number' ? score : 0), canvas.width / 2, canvas.height / 2 - 20);
             ctx.fillStyle = isHoveringButton ? '#999' : '#DDD';
             ctx.fillRect(playAgainButton.x, playAgainButton.y, playAgainButton.width, playAgainButton.height);
             ctx.fillStyle = 'black'; ctx.font = '18px Arial';
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Play Again', playAgainButton.x + playAgainButton.width / 2, playAgainButton.y + playAgainButton.height / 2);
             ctx.fillStyle = 'white'; ctx.font = '18px Arial';
             ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
             ctx.fillText('Top Scores:', canvas.width / 2, canvas.height / 2 + 130);
             ctx.font = '16px Arial';
             topScores.forEach((s, index) => {
                 if (index < leaderboardSize) ctx.fillText(`${index + 1}. ${s}`, canvas.width / 2, canvas.height / 2 + 160 + (index * 20));
             });
             if (topScores.length === 0) ctx.fillText("No scores yet!", canvas.width / 2, canvas.height / 2 + 160);
        }

        // --- Main Game Loop ---
        function updateGame() {
            requestAnimationFrame(updateGame);

            if (!gameRunning) {
                drawGameOverScreen();
                return;
            }

            let now = performance.now();
            let deltaTime = (lastFrameTime > 0) ? (now - lastFrameTime) / 1000 : 0;
            lastFrameTime = now;

            // Input & Movement
            if (keys[39]) { if (player.velX < player.speed) player.velX++; }
            else if (keys[37]) { if (player.velX > -player.speed) player.velX--; }
            else { player.velX *= friction; }
            player.velY += gravity;
            player.x += player.velX;
            player.y += player.velY;

            // Falling Off Bottom Check
            if (player.y >= canvas.height) {
                gameOver("Fell off screen");
                return; // Exit this frame's logic
            }

            // Platform & Enemy Logic
             platforms.forEach(platform => {
                // Update falling platforms
                if (platform.isFalling) {
                    platform.y += platformFallSpeed;
                    // <<< Sync enemy Y if falling >>>
                    if (platform.enemy) {
                        platform.enemy.y = platform.y - platform.enemy.height;
                    }
                }
                // Update standing timer
                else if (platform.isPlayerOn) {
                    platform.standTimer += deltaTime;
                    if (platform.standTimer >= platformFallDelay) {
                        platform.isFalling = true; platform.isPlayerOn = false;
                        if (player.currentPlatform === platform) player.currentPlatform = null;
                    }
                } else { platform.standTimer = 0; }

                // <<< Update Enemy Position (if not falling) >>>
                if (platform.enemy && !platform.isFalling) {
                    let enemy = platform.enemy;
                    enemy.y = platform.y - enemy.height; // Keep Y synced
                    if (enemy.type === 'type2') {
                        enemy.x += enemy.speed * enemy.direction;
                        if (enemy.x <= platform.x || enemy.x + enemy.width >= platform.x + platform.width) {
                            enemy.direction *= -1;
                            enemy.x = Math.max(platform.x, Math.min(enemy.x, platform.x + platform.width - enemy.width));
                        }
                    }
                }
            });


            // Screen Scroll & Recycling
            let scrollOffset = 0;
            if (player.y < canvas.height / 4) {
                scrollOffset = Math.abs(player.velY) > 1 ? Math.abs(player.velY) : (canvas.height / 4 - player.y);
                if (scrollOffset < 0) scrollOffset = 0;
                player.y += scrollOffset; highestYReached += scrollOffset;

                platforms.forEach(platform => {
                    platform.y += scrollOffset;
                    // <<< Sync enemy Y during scroll >>>
                    if (platform.enemy) {
                         platform.enemy.y = platform.y - platform.enemy.height;
                    }

                    if (platform.y > canvas.height) {
                        // Reset state
                        platform.isFalling = false; platform.standTimer = 0; platform.isPlayerOn = false;
                        platform.enemy = null; // <<< Remove enemy on recycle
                        // Assign label
                        platformCounter++; platform.labelNumber = (platformCounter % 10 === 0) ? platformCounter : null;

                        // Reposition platform first
                        let topPlatformY = Math.min(...platforms.map(p => p.y).filter(y => y > -Infinity && y < canvas.height));
                        if (topPlatformY === Infinity) topPlatformY = player.y - canvas.height / 2;
                        let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                        platform.y = topPlatformY - spacing; platform.x = Math.random() * (canvas.width - platform.width);

                        // <<< Add new enemy *after* positioning >>>
                        if (Math.random() < enemyChance) {
                            platform.enemy = createEnemy(platform); // Enemy created based on new platform position
                            // No need to reposition Y again, createEnemy does it based on platform.y
                            platform.enemy.x = platform.x + (platform.width / 2) - (platform.enemy.width / 2); // Center X
                        }
                    }
                });
            }

            // Collision Detection
            if (player.x >= canvas.width - player.width) { player.x = canvas.width - player.width; player.velX = 0; }
            else if (player.x <= 0) { player.x = 0; player.velX = 0; }

            let onPlatformThisFrame = null;
            let hitGroundThisFrame = false; // Track if ground was specifically hit this frame

            // Check Ground Collision (triggers game over if landing after first jump)
            if (player.y >= canvas.height - player.height) {
                if (player.velY > 0 && !player.onGround) {
                    gameOver("Landed on ground");
                    hitGroundThisFrame = true;
                } else if (player.velY >= 0 && player.onGround) {
                    player.y = canvas.height - player.height;
                    player.velY = 0;
                    player.jumping = false;
                }
            }

            // Check Platform and Enemy Collisions (Only if game is still running)
            if (gameRunning) {
                 for (const platform of platforms) {
                    // <<< Enemy collision check >>>
                    if (platform.enemy && !platform.isFalling) {
                        let enemy = platform.enemy;
                        if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                            player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                            gameOver("Hit enemy");
                            break; // Exit the loop immediately if game over
                        }
                    }
                     if (!gameRunning) break; // Exit loop if hitting enemy ended game

                    // Platform collision check
                    if (!platform.isFalling && !onPlatformThisFrame) {
                         if (player.velY >= 0 && player.x < platform.x + platform.width && player.x + player.width > platform.x &&
                             player.y + player.height >= platform.y && player.y + player.height <= platform.y + platform.height + Math.max(1, player.velY)) {
                            let landingY = platform.y - player.height;
                            if (landingY < highestYReached) {
                                let heightGain = Math.round(highestYReached - landingY);
                                score += heightGain; score += Math.round(heightGain * 0.1);
                                highestYReached = landingY;
                            }
                            player.jumping = false; player.velY = 0; player.y = platform.y - player.height;
                            onPlatformThisFrame = platform;
                            // No need to set onGroundThisFrame here, handled later
                        }
                    }
                }
            }


            // Update Player Status (Only if game still running)
             if (gameRunning) {
                player.onGround = !onPlatformThisFrame && player.y >= canvas.height - player.height;

                if (onPlatformThisFrame && player.currentPlatform !== onPlatformThisFrame) {
                    if (player.currentPlatform) { player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0; }
                    player.currentPlatform = onPlatformThisFrame;
                    player.currentPlatform.isPlayerOn = true; player.currentPlatform.standTimer = 0;
                    player.onGround = false;
                } else if (!onPlatformThisFrame && !player.onGround && player.currentPlatform) {
                     player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                     player.currentPlatform = null;
                } else if (player.onGround && player.currentPlatform) {
                     player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                     player.currentPlatform = null;
                }
            }

            // --- Drawing ---
            // Draw the game state only if it was running at the start of this frame's logic
            drawGame();
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', function(e) {
             if (e.key === "ArrowRight" || e.keyCode === 39) keys[39] = true;
             if (e.key === "ArrowLeft" || e.keyCode === 37) keys[37] = true;
             if (e.key === " " || e.keyCode === 32) {
                 keys[32] = true;
                 // Jump initiation
                 if (gameRunning && !player.jumping && (player.currentPlatform || player.onGround)) {
                     player.jumping = true;
                     player.onGround = false; // Leave ground state
                     player.velY = baseJump - Math.abs(player.velX * 0.1);
                     if (player.currentPlatform) {
                         player.currentPlatform.isPlayerOn = false;
                         player.currentPlatform.standTimer = 0;
                         player.currentPlatform = null;
                     }
                 }
             }
         });

         window.addEventListener('keyup', function(e) {
             if (e.key === "ArrowRight" || e.keyCode === 39) keys[39] = false;
             if (e.key === "ArrowLeft" || e.keyCode === 37) keys[37] = false;
             if (e.key === " " || e.keyCode === 32) keys[32] = false;
         });

        canvas.addEventListener('click', function(event) {
            if (!gameRunning) {
                const rect = canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const clickY = event.clientY - rect.top;
                if (clickX >= playAgainButton.x && clickX <= playAgainButton.x + playAgainButton.width &&
                    clickY >= playAgainButton.y && clickY <= playAgainButton.y + playAgainButton.height) {
                    resetGame(); // Reset game state, gameRunning becomes true
                }
            }
        });

         canvas.addEventListener('mousemove', function(event) {
             if (!gameRunning) {
                 const rect = canvas.getBoundingClientRect();
                 const mouseX = event.clientX - rect.left;
                 const mouseY = event.clientY - rect.top;
                 if (mouseX >= playAgainButton.x && mouseX <= playAgainButton.x + playAgainButton.width &&
                     mouseY >= playAgainButton.y && mouseY <= playAgainButton.y + playAgainButton.height) {
                     if (!isHoveringButton) { isHoveringButton = true; canvas.classList.add('button-hover'); }
                 } else {
                     if (isHoveringButton) { isHoveringButton = false; canvas.classList.remove('button-hover'); }
                 }
             } else {
                  if (isHoveringButton) { isHoveringButton = false; canvas.classList.remove('button-hover'); }
             }
         });

        // --- Initial Setup ---
        loadScores();
        resetGame(); // Initialize game variables and sets gameRunning = true
        updateGame(); // Start the main game loop

    </script>
</body>
</html>