<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game with Screen Scroll and Score</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { background-color: #87CEEB; display: block; margin: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game settings
        const gravity = 0.5;
        const friction = 0.8;
        const baseJump = -10; // Base jump velocity

        // Player
        let player = {
            x: canvas.width / 2 - 10,
            y: canvas.height - 20,   // Start exactly on the ground
            width: 20,
            height: 20,
            speed: 5,
            velX: 0,
            velY: 0,
            jumping: false
        };

        // Platforms
        let platforms = [];
        const platformWidth = 100;
        const platformHeight = 10;
        for(let i = 0; i < 10; i++) {
            platforms.push({
                x: Math.random() * (canvas.width - platformWidth),
                y: canvas.height - 100 - (Math.random() * 80 + 80) * i, // Platforms start higher up
                width: platformWidth,
                height: platformHeight
            });
        }

        // === Score Variables ===
        let score = 0;
        // Track the highest Y the player has landed on. Initialized to ground level.
        let highestYReached = canvas.height - player.height;

        // Key Listener
        let keys = [];
        window.addEventListener('keydown', function(e) {
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping) { // Space key for jump
                player.jumping = true;
                player.velY = baseJump - Math.abs(player.velX * 0.1);
            }
        });
        window.addEventListener('keyup', function(e) {
            keys[e.keyCode] = false;
        });

        function updateGame() {
            // Handle horizontal movement input
            if (keys[39]) { // right arrow
                if (player.velX < player.speed) {
                    player.velX++;
                }
            } else if (keys[37]) { // left arrow
                if (player.velX > -player.speed) {
                    player.velX--;
                }
            } else {
                 player.velX *= friction; // Apply friction when not moving
            }

            // Apply gravity
            player.velY += gravity;

            // Update position
            player.x += player.velX;
            player.y += player.velY;

            // Screen scroll
            let scrollOffset = 0;
            if (player.y < canvas.height / 4) {
                 scrollOffset = Math.abs(player.velY) > 1 ? Math.abs(player.velY) : (canvas.height / 4 - player.y);
                 if (scrollOffset < 0) scrollOffset = 0;

                player.y += scrollOffset; // Adjust player position relative to scroll
                highestYReached += scrollOffset; // Adjust the score benchmark relative to the scroll

                // Move platforms down and recycle them
                platforms.forEach(platform => {
                    platform.y += scrollOffset;
                    if (platform.y > canvas.height) {
                         let topPlatformY = Math.min(...platforms.map(p => p.y));
                         platform.y = Math.min(topPlatformY - (Math.random() * 60 + 80), player.y - canvas.height / 2);
                         platform.x = Math.random() * (canvas.width - platform.width);
                    }
                });
            }

            // Horizontal edge collision
            if (player.x >= canvas.width - player.width) {
                player.x = canvas.width - player.width;
                player.velX = 0;
            } else if (player.x <= 0) {
                player.x = 0;
                player.velX = 0;
            }

            // Ground collision
            if(player.y >= canvas.height - player.height){
                player.y = canvas.height - player.height;
                if (player.velY > 0) {
                    player.jumping = false;
                    player.velY = 0;
                }
                // Reset highestYReached if hitting the ground prevents score farming
                // highestYReached = canvas.height - player.height;
            }

            // Platform collision
            platforms.forEach(platform => {
                if (
                    player.velY >= 0 && // Check if falling/still
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height >= platform.y &&
                    player.y + player.height <= platform.y + platform.height + player.velY
                ) {
                    // --- Scoring Logic ---
                    let landingY = platform.y - player.height;
                    // Award score only if this landing is higher than the previous highest
                    if (landingY < highestYReached) {
                        let heightGain = Math.round(highestYReached - landingY);
                        score += heightGain; // Base score for height difference
                        score += Math.round(heightGain * 0.1); // Bonus for larger jumps
                        highestYReached = landingY; // Update the benchmark
                    }
                    // --- End of Scoring Logic ---

                    // Handle landing
                    player.jumping = false;
                    player.velY = 0;
                    player.y = platform.y - player.height; // Snap player to platform top
                }
            });

            // --- Drawing ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw platforms
            ctx.fillStyle = 'black';
            platforms.forEach(platform => {
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            });

            // Draw Score
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, 30);

            // Optional: Game Over check
             if (player.y > canvas.height + 100) {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 ctx.fillStyle = 'white';
                 ctx.font = '40px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
                 ctx.font = '20px Arial';
                 ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
                 ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 50);
                 return; // Stop the game loop
             }

            requestAnimationFrame(updateGame); // Loop the game
        }

        updateGame(); // Start the game
    </script>
</body>
</html>
