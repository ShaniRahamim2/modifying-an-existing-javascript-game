<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game - With Images!</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { display: block; margin: auto; cursor: default; } /* Removed background color */
        #gameCanvas.button-hover { cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- Constants and Settings ---
        const gravity = 0.5;
        const friction = 0.8;
        const baseJump = -12;
        const platformFallDelay = 4;
        const platformFallSpeed = 2;
        const enemyChance = 0.05;
        const enemyWidth = 20; 
        const enemyHeight = 20;
        const enemyType2Speed = 1;
        const platformWidth = 100;
        const platformHeight = 20; 
        const initialPlatformMaxHeight = 90;
        const platformMinSpacing = 80;
        const platformMaxSpacing = 150;
        const leaderboardSize = 10;
        const localStorageKey = 'platformerTopScores';
        const playerWidth = 25; 
        const playerHeight = 25;

        // --- Image Asset Paths  ---
        const PLAYER_IMG_SRC = './MarioNSMBUDeluxe.png';
        const PLATFORM_IMG_SRC = './grass.jpeg'; 
        const ENEMY1_IMG_SRC = './devil1.jpg'; 
        const ENEMY2_IMG_SRC = './devil2.jpg'; 
        const BACKGROUND_IMG_SRC = './blue.jpg'; 

        // --- Game State Variables ---
        let player;
        let platforms;
        let platformCounter;
        let score;
        let highestYReached;
        let keys = {};
        let lastFrameTime = 0;
        let gameRunning = false;
        let topScores = [];

        // --- Image Objects ---
        let playerImg;
        let platformImg;
        let enemy1Img;
        let enemy2Img;
        let backgroundImg;
        let imagesLoaded = 0;
        const totalImages = 5; // Total number of images to load

        // --- Button Definition ---
        const playAgainButton = { 
            x: canvas.width / 2 - 75, y: canvas.height / 2 + 70,
            width: 150, height: 40
        };
        let isHoveringButton = false;

        // --- Helper Functions ---

        function loadScores() { 
             const storedScores = localStorage.getItem(localStorageKey);
             if (storedScores) {
                 try {
                     topScores = JSON.parse(storedScores);
                     if (!Array.isArray(topScores)) topScores = [];
                     topScores = topScores.map(Number).filter(Number.isFinite).sort((a, b) => b - a);
                 } catch (e) { console.error("Error parsing scores:", e); topScores = []; }
             } else { topScores = []; }
        }

        function saveScores() { 
              if (typeof score === 'number' && isFinite(score)) {
                   topScores.push(score);
                   topScores.sort((a, b) => b - a);
                   topScores = topScores.slice(0, leaderboardSize);
                   localStorage.setItem(localStorageKey, JSON.stringify(topScores));
              } else {
                   console.warn("Invalid score, not saving:", score);
                   topScores.sort((a, b) => b - a);
                   localStorage.setItem(localStorageKey, JSON.stringify(topScores.slice(0, leaderboardSize)));
              }
        }

        // <<< Modified Enemy Creation >>>
        function createEnemy(platform) {
            let enemyType = (Math.random() < 0.5) ? 'type1' : 'type2';
            return {
                width: enemyWidth, height: enemyHeight, type: enemyType,
                x: platform.x + (platform.width / 2) - (enemyWidth / 2),
                y: platform.y - enemyHeight, // Place on top of platform
                direction: (enemyType === 'type2') ? 1 : 0,
                speed: (enemyType === 'type2') ? enemyType2Speed : 0
            };
        }

        // --- Game Initialization / Reset ---
        function resetGame() {
            console.log("Resetting game...");
            // Initialize player using player image dimensions
            player = {
                x: canvas.width / 2 - (playerWidth / 2), // Center based on image width
                y: canvas.height - playerHeight,      // Start on ground
                width: playerWidth, height: playerHeight, speed: 5,
                velX: 0, velY: 0, jumping: false,
                currentPlatform: null, onGround: true
            };

            platforms = [];
            platformCounter = 0;

            // Initial Platform Generation
            platformCounter++;
            let firstPlatformY = player.y - (Math.random() * (initialPlatformMaxHeight - platformHeight) + platformHeight + 10);
            let firstPlatform = {
                x: Math.random() * (canvas.width - platformWidth), y: firstPlatformY,
                width: platformWidth, height: platformHeight, standTimer: 0,
                isFalling: false, isPlayerOn: false,
                labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
                enemy: null
            };
            if (Math.random() < enemyChance) firstPlatform.enemy = createEnemy(firstPlatform);
            platforms.push(firstPlatform);

            let lastPlatformY = firstPlatformY;
            for (let i = 1; i < 10; i++) {
                platformCounter++;
                let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                let nextY = lastPlatformY - spacing;
                let newPlatform = {
                    x: Math.random() * (canvas.width - platformWidth), y: nextY,
                    width: platformWidth, height: platformHeight, standTimer: 0,
                    isFalling: false, isPlayerOn: false,
                    labelNumber: (platformCounter % 10 === 0) ? platformCounter : null,
                    enemy: null
                };
                if (Math.random() < enemyChance) newPlatform.enemy = createEnemy(newPlatform);
                platforms.push(newPlatform);
                lastPlatformY = nextY;
            }

            score = 0;
            highestYReached = canvas.height;
            keys = {};
            lastFrameTime = performance.now();
            gameRunning = true;
        }

        // --- Game Over Handling ---
        function gameOver(reason) { 
             if (!gameRunning) return;
             console.log("Game Over:", reason);
             gameRunning = false;
             saveScores();
        }

        // --- Drawing Functions ---
        function drawGame() {
             ctx.clearRect(0, 0, canvas.width, canvas.height);

             // <<< Draw Background Image FIRST >>>
             if (backgroundImg) {
                 ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
             } else {
                 // Fallback background color if image fails to load
                 ctx.fillStyle = '#87CEEB';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
             }

             // <<< Draw Player Image >>>
             if (playerImg) {
                 ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
             } else { // Fallback rectangle
                 ctx.fillStyle = 'red';
                 ctx.fillRect(player.x, player.y, player.width, player.height);
             }

             // Draw platforms and enemies
             platforms.forEach(platform => {
                 // <<< Draw Platform Image >>>
                 if (platformImg) {
                     ctx.drawImage(platformImg, platform.x, platform.y, platform.width, platform.height);
                 } else { // Fallback rectangle
                     if (platform.isPlayerOn && !platform.isFalling) ctx.fillStyle = '#555';
                     else if (platform.isFalling) ctx.fillStyle = '#AAA';
                     else ctx.fillStyle = 'black';
                     ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                 }

                 // Draw Label (over the platform image)
                 if (platform.labelNumber !== null) {
                     ctx.fillStyle = 'black'; // Change label color for visibility
                     ctx.font = '10px Arial Black'; // Make font bolder
                     ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                     ctx.strokeStyle = 'white'; // Outline color
                     ctx.lineWidth = 1;         // Outline width
                     ctx.strokeText(platform.labelNumber, platform.x + platform.width / 2, platform.y + platform.height / 2);
                     ctx.fillText(platform.labelNumber, platform.x + platform.width / 2, platform.y + platform.height / 2);
                 }

                 // <<< Draw Enemy Image >>>
                 if (platform.enemy) {
                      let enemy = platform.enemy;
                      let imgToDraw = (enemy.type === 'type1') ? enemy1Img : enemy2Img;
                      if (imgToDraw) {
                          ctx.drawImage(imgToDraw, enemy.x, enemy.y, enemy.width, enemy.height);
                      } else { // Fallback rectangle
                          ctx.fillStyle = (enemy.type === 'type1') ? 'orange' : 'purple';
                          ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                      }
                 }
             });

             // Draw Score
             ctx.fillStyle = 'black'; ctx.font = '20px Arial';
             ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
             ctx.fillText('Score: ' + score, 10, 30);
        }

        function drawGameOverScreen() { 
             // Draw Background Image FIRST
             if (backgroundImg) {
                 ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
             } else {
                 ctx.fillStyle = '#87CEEB';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
             }

             // Overlay
             ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
             ctx.fillRect(0, 0, canvas.width, canvas.height);

             // Text (GAME OVER, Score)
             ctx.fillStyle = 'white';
             ctx.font = '40px Arial'; ctx.textAlign = 'center';
             ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 60);
             ctx.font = '20px Arial';
             ctx.fillText('Final Score: ' + (typeof score === 'number' ? score : 0), canvas.width / 2, canvas.height / 2 - 20);

             // Play Again Button
             ctx.fillStyle = isHoveringButton ? '#999' : '#DDD';
             ctx.fillRect(playAgainButton.x, playAgainButton.y, playAgainButton.width, playAgainButton.height);
             ctx.fillStyle = 'black'; ctx.font = '18px Arial';
             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
             ctx.fillText('Play Again', playAgainButton.x + playAgainButton.width / 2, playAgainButton.y + playAgainButton.height / 2);

             // Leaderboard
             ctx.fillStyle = 'white'; ctx.font = '18px Arial';
             ctx.textAlign = 'center'; ctx.textBaseline = 'alphabetic';
             ctx.fillText('Top Scores:', canvas.width / 2, canvas.height / 2 + 130);
             ctx.font = '16px Arial';
             topScores.forEach((s, index) => {
                 if (index < leaderboardSize) ctx.fillText(`${index + 1}. ${s}`, canvas.width / 2, canvas.height / 2 + 160 + (index * 20));
             });
             if (topScores.length === 0) ctx.fillText("No scores yet!", canvas.width / 2, canvas.height / 2 + 160);
        }

        // --- Main Game Loop ---
        function updateGame() {
            requestAnimationFrame(updateGame);

            if (!gameRunning) {
                drawGameOverScreen();
                return;
            }

            // --- Game Logic ---
            let now = performance.now();
            let deltaTime = (lastFrameTime > 0) ? (now - lastFrameTime) / 1000 : 0;
            lastFrameTime = now;

            // Input & Movement
            if (keys[39]) { if (player.velX < player.speed) player.velX++; }
            else if (keys[37]) { if (player.velX > -player.speed) player.velX--; }
            else { player.velX *= friction; }
            player.velY += gravity;
            player.x += player.velX;
            player.y += player.velY;

            // Falling Off Bottom Check
            if (player.y >= canvas.height) {
                gameOver("Fell off screen"); return;
            }

            // Platform & Enemy Logic
            if (gameRunning) {
                 platforms.forEach(platform => {
                     if (platform.isFalling) { /* ... falling logic ... */
                          platform.y += platformFallSpeed;
                          if (platform.enemy) platform.enemy.y = platform.y - platform.enemy.height;
                     } else if (platform.isPlayerOn) { /* ... stand timer ... */
                          platform.standTimer += deltaTime;
                          if (platform.standTimer >= platformFallDelay) {
                               platform.isFalling = true; platform.isPlayerOn = false;
                               if (player.currentPlatform === platform) player.currentPlatform = null;
                          }
                     } else { platform.standTimer = 0; }

                     if (platform.enemy && !platform.isFalling) { /* ... enemy logic ... */
                          let enemy = platform.enemy;
                          enemy.y = platform.y - enemy.height;
                          if (enemy.type === 'type2') {
                               enemy.x += enemy.speed * enemy.direction;
                               if (enemy.x <= platform.x || enemy.x + enemy.width >= platform.x + platform.width) {
                                    enemy.direction *= -1;
                                    enemy.x = Math.max(platform.x, Math.min(enemy.x, platform.x + platform.width - enemy.width));
                               }
                          }
                     }
                 });
            }

            // Screen Scroll & Recycling
            if (gameRunning) {
                 let scrollOffset = 0;
                 if (player.y < canvas.height / 4) { 
                     scrollOffset = Math.abs(player.velY) > 1 ? Math.abs(player.velY) : (canvas.height / 4 - player.y);
                     if (scrollOffset < 0) scrollOffset = 0;
                     player.y += scrollOffset; highestYReached += scrollOffset;

                     platforms.forEach(platform => {
                         platform.y += scrollOffset;
                         if (platform.enemy) platform.enemy.y = platform.y - platform.enemy.height;

                         if (platform.y > canvas.height) {
                             platform.isFalling = false; platform.standTimer = 0; platform.isPlayerOn = false; platform.enemy = null;
                             platformCounter++; platform.labelNumber = (platformCounter % 10 === 0) ? platformCounter : null;

                             if (Math.random() < enemyChance) platform.enemy = createEnemy(platform);

                             let topPlatformY = Math.min(...platforms.map(p => p.y).filter(y => y > -Infinity && y < canvas.height));
                             if (topPlatformY === Infinity) topPlatformY = player.y - canvas.height / 2;
                             let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                             platform.y = topPlatformY - spacing; platform.x = Math.random() * (canvas.width - platform.width);

                              if (platform.enemy) {
                                  platform.enemy.x = platform.x + (platform.width / 2) - (platform.enemy.width / 2);
                                  platform.enemy.y = platform.y - platform.enemy.height;
                              }
                         }
                     });
                 }
            }

            // Collision Detection
            if (gameRunning) {
                 if (player.x >= canvas.width - player.width) { player.x = canvas.width - player.width; player.velX = 0; }
                 else if (player.x <= 0) { player.x = 0; player.velX = 0; }

                 let onPlatformThisFrame = null;
                 let hitGroundThisFrame = false;

                 // Ground Collision Check (triggers game over)
                 if (player.y >= canvas.height - player.height) {
                     if (player.velY > 0 && !player.onGround) { gameOver("Landed on ground"); hitGroundThisFrame = true; }
                     else if (player.velY >= 0 && player.onGround) { player.y = canvas.height - player.height; player.velY = 0; player.jumping = false; }
                 }

                 // Platform/Enemy Collisions
                 if (gameRunning) { // Re-check as ground collision might have ended game
                     for (const platform of platforms) {
                         // Enemy collision
                         if (platform.enemy && !platform.isFalling) {
                             let enemy = platform.enemy;
                             if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                                 player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                                 gameOver("Hit enemy"); break; // Exit loop
                             }
                         }
                         if (!gameRunning) break; // Exit if enemy collision ended game

                         // Platform collision
                         if (!platform.isFalling && !onPlatformThisFrame) {
                              if (player.velY >= 0 && player.x < platform.x + platform.width && player.x + player.width > platform.x &&
                                  player.y + player.height >= platform.y && player.y + player.height <= platform.y + platform.height + Math.max(1, player.velY)) {
                                 let landingY = platform.y - player.height;
                                 if (landingY < highestYReached) {
                                     let heightGain = Math.round(highestYReached - landingY);
                                     score += heightGain; score += Math.round(heightGain * 0.1);
                                     highestYReached = landingY;
                                 }
                                 player.jumping = false; player.velY = 0; player.y = platform.y - player.height;
                                 onPlatformThisFrame = platform;
                             }
                         }
                     }
                 }

                // Update Player Status
                if (gameRunning) {
                     player.onGround = !onPlatformThisFrame && player.y >= canvas.height - player.height;

                     if (onPlatformThisFrame && player.currentPlatform !== onPlatformThisFrame) {
                         if (player.currentPlatform) { player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0; }
                         player.currentPlatform = onPlatformThisFrame;
                         player.currentPlatform.isPlayerOn = true; player.currentPlatform.standTimer = 0;
                         player.onGround = false;
                     } else if (!onPlatformThisFrame && !player.onGround && player.currentPlatform) {
                          player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                          player.currentPlatform = null;
                     } else if (player.onGround && player.currentPlatform) {
                          player.currentPlatform.isPlayerOn = false; player.currentPlatform.standTimer = 0;
                          player.currentPlatform = null;
                     }
                 }
            }

            // --- Drawing ---
            if (gameRunning) {
                drawGame(); // Draw the active game state
            }
            // If game ended this frame, the next frame's check will draw the game over screen
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', function(e) { 
              if (e.key === "ArrowRight" || e.keyCode === 39) keys[39] = true;
              if (e.key === "ArrowLeft" || e.keyCode === 37) keys[37] = true;
              if (e.key === " " || e.keyCode === 32) {
                  keys[32] = true;
                  if (gameRunning && !player.jumping && (player.currentPlatform || player.onGround)) {
                      player.jumping = true;
                      player.onGround = false;
                      player.velY = baseJump - Math.abs(player.velX * 0.1);
                      if (player.currentPlatform) {
                          player.currentPlatform.isPlayerOn = false;
                          player.currentPlatform.standTimer = 0;
                          player.currentPlatform = null;
                      }
                  }
              }
          });
         window.addEventListener('keyup', function(e) { 
              if (e.key === "ArrowRight" || e.keyCode === 39) keys[39] = false;
              if (e.key === "ArrowLeft" || e.keyCode === 37) keys[37] = false;
              if (e.key === " " || e.keyCode === 32) keys[32] = false;
          });
        canvas.addEventListener('click', function(event) { 
             if (!gameRunning) {
                 const rect = canvas.getBoundingClientRect();
                 const clickX = event.clientX - rect.left;
                 const clickY = event.clientY - rect.top;
                 if (clickX >= playAgainButton.x && clickX <= playAgainButton.x + playAgainButton.width &&
                     clickY >= playAgainButton.y && clickY <= playAgainButton.y + playAgainButton.height) {
                     resetGame();
                 }
             }
         });
         canvas.addEventListener('mousemove', function(event) { 
              if (!gameRunning) {
                  const rect = canvas.getBoundingClientRect();
                  const mouseX = event.clientX - rect.left;
                  const mouseY = event.clientY - rect.top;
                  if (mouseX >= playAgainButton.x && mouseX <= playAgainButton.x + playAgainButton.width &&
                      mouseY >= playAgainButton.y && mouseY <= playAgainButton.y + playAgainButton.height) {
                      if (!isHoveringButton) { isHoveringButton = true; canvas.classList.add('button-hover'); }
                  } else {
                      if (isHoveringButton) { isHoveringButton = false; canvas.classList.remove('button-hover'); }
                  }
              } else {
                   if (isHoveringButton) { isHoveringButton = false; canvas.classList.remove('button-hover'); }
              }
          });

        // --- Image Loading and Game Start ---
        function imageLoaded() {
            imagesLoaded++;
            console.log(`Image loaded (${imagesLoaded}/${totalImages})`);
            if (imagesLoaded === totalImages) {
                console.log("All images loaded. Starting game.");
                resetGame(); // Initialize game state NOW that images are ready
                updateGame(); // Start the main game loop
            }
        }

        function loadImage(src) {
            const img = new Image();
            img.onload = imageLoaded;
            img.onerror = () => {
                 console.error(`Failed to load image: ${src}`);
                 imageLoaded(); // Still count it as 'loaded' (failed) to not stall the game
             };
            img.src = src;
            return img;
        }

        console.log("Loading images...");
        loadScores(); // Load scores first

        playerImg = loadImage(PLAYER_IMG_SRC);
        platformImg = loadImage(PLATFORM_IMG_SRC);
        enemy1Img = loadImage(ENEMY1_IMG_SRC);
        enemy2Img = loadImage(ENEMY2_IMG_SRC);
        backgroundImg = loadImage(BACKGROUND_IMG_SRC);


    </script>
</body>
</html>