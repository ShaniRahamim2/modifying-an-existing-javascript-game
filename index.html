<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game - Numbered Falling Platforms</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; }
        #gameCanvas { background-color: #87CEEB; display: block; margin: auto; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game settings
        const gravity = 0.5;
        const friction = 0.8;
        const baseJump = -12; // << Increased base jump slightly for better reach
        const platformFallDelay = 4;
        const platformFallSpeed = 2;

        // Player
        let player = {
            x: canvas.width / 2 - 10,
            y: canvas.height - 20, // Start on ground
            width: 20,
            height: 20,
            speed: 5,
            velX: 0,
            velY: 0,
            jumping: false,
            currentPlatform: null
        };

        // Platforms & Global Counter
        let platforms = [];
        let platformCounter = 0;
        const platformWidth = 100;
        const platformHeight = 10;
        const initialPlatformMaxHeight = 90; // Max height needed for the *first* jump from ground
        const platformMinSpacing = 80;       // Min vertical distance between platforms
        const platformMaxSpacing = 150;      // Max vertical distance between platforms

        // --- Revised Initial Platform Generation ---
        // Create the very first platform at a reachable height from the ground
        platformCounter++;
        let firstPlatformY = player.y - (Math.random() * (initialPlatformMaxHeight - platformHeight) + platformHeight + 10); // Ensure it's above player, but reachable
        platforms.push({
            x: Math.random() * (canvas.width - platformWidth),
            y: firstPlatformY,
            width: platformWidth,
            height: platformHeight,
            standTimer: 0,
            isFalling: false,
            isPlayerOn: false,
            labelNumber: (platformCounter % 10 === 0) ? platformCounter : null
        });

        // Create subsequent platforms, spaced progressively higher
        let lastPlatformY = firstPlatformY;
        for(let i = 1; i < 10; i++) {
            platformCounter++;
            let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
            let nextY = lastPlatformY - spacing; // Place above the last one
            let newPlatform = {
                x: Math.random() * (canvas.width - platformWidth),
                y: nextY,
                width: platformWidth,
                height: platformHeight,
                standTimer: 0,
                isFalling: false,
                isPlayerOn: false,
                labelNumber: null
            };
            if (platformCounter % 10 === 0) {
                newPlatform.labelNumber = platformCounter;
            }
            platforms.push(newPlatform);
            lastPlatformY = nextY; // Use this platform's Y for the next spacing calculation
        }
        // --- End Revised Generation ---


        // Score Variables
        let score = 0;
        let highestYReached = canvas.height - player.height;

        // Key Listener & Timing
        let keys = [];
        let lastFrameTime = performance.now();

        window.addEventListener('keydown', function(e) {
            keys[e.keyCode] = true;
            if (e.keyCode == 32 && !player.jumping) { // Space key
                player.jumping = true;
                player.velY = baseJump - Math.abs(player.velX * 0.1);
                if (player.currentPlatform && player.currentPlatform !== 'ground') {
                    player.currentPlatform.isPlayerOn = false;
                    player.currentPlatform.standTimer = 0;
                    player.currentPlatform = null;
                }
            }
        });
        window.addEventListener('keyup', function(e) {
            keys[e.keyCode] = false;
        });

        function updateGame() {
            let now = performance.now();
            let deltaTime = (now - lastFrameTime) / 1000;
            lastFrameTime = now;

            // Horizontal movement
            if (keys[39]) {
                if (player.velX < player.speed) player.velX++;
            } else if (keys[37]) {
                if (player.velX > -player.speed) player.velX--;
            } else {
                 player.velX *= friction;
            }

            // Apply gravity
            player.velY += gravity;

            // Update position
            player.x += player.velX;
            player.y += player.velY;

            // Platform State Update (Falling/Timers)
            platforms.forEach(platform => {
                if (platform.isFalling) {
                    platform.y += platformFallSpeed;
                }
                else if (platform.isPlayerOn) {
                    platform.standTimer += deltaTime;
                    if (platform.standTimer >= platformFallDelay) {
                        platform.isFalling = true;
                        platform.isPlayerOn = false;
                        if (player.currentPlatform === platform) {
                            player.currentPlatform = null;
                        }
                    }
                } else {
                     platform.standTimer = 0;
                }
            });

            // Screen scroll & Platform Recycling
            let scrollOffset = 0;
            if (player.y < canvas.height / 4) {
                 scrollOffset = Math.abs(player.velY) > 1 ? Math.abs(player.velY) : (canvas.height / 4 - player.y);
                 if (scrollOffset < 0) scrollOffset = 0;

                player.y += scrollOffset;
                highestYReached += scrollOffset;

                platforms.forEach(platform => {
                    platform.y += scrollOffset;
                    if (platform.y > canvas.height) {
                        // Reset platform state
                        platform.isFalling = false;
                        platform.standTimer = 0;
                        platform.isPlayerOn = false;

                        // Increment counter and check for label
                        platformCounter++;
                        platform.labelNumber = (platformCounter % 10 === 0) ? platformCounter : null;

                        // Reposition recycled platform above the highest one
                        let topPlatformY = Math.min(...platforms.map(p => p.y).filter(y => y > -Infinity)); // Find highest valid Y
                        let spacing = Math.random() * (platformMaxSpacing - platformMinSpacing) + platformMinSpacing;
                        platform.y = topPlatformY - spacing; // Position above the current top platform
                        platform.x = Math.random() * (canvas.width - platform.width);
                    }
                });
            }

            // Horizontal edge collision
            if (player.x >= canvas.width - player.width) {
                player.x = canvas.width - player.width;
                player.velX = 0;
            } else if (player.x <= 0) {
                player.x = 0;
                player.velX = 0;
            }

            // --- Collision Detection ---
            let onPlatformThisFrame = null;

            // Ground collision
            if(player.y >= canvas.height - player.height){
                player.y = canvas.height - player.height;
                if (player.velY > 0) {
                    player.jumping = false;
                    player.velY = 0;
                    onPlatformThisFrame = 'ground';
                }
            }

            // Platform collision
            platforms.forEach(platform => {
                if (platform.isFalling) return; // No collision with falling platforms

                if (
                    player.velY >= 0 &&
                    player.x < platform.x + platform.width &&
                    player.x + player.width > platform.x &&
                    player.y + player.height >= platform.y &&
                    player.y + player.height <= platform.y + platform.height + player.velY
                ) {
                    // Score calculation
                    let landingY = platform.y - player.height;
                    if (landingY < highestYReached) {
                        let heightGain = Math.round(highestYReached - landingY);
                        score += heightGain;
                        score += Math.round(heightGain * 0.1);
                        highestYReached = landingY;
                    }
                    // Landing physics
                    player.jumping = false;
                    player.velY = 0;
                    player.y = platform.y - player.height;
                    onPlatformThisFrame = platform;
                }
            });

            // --- Update Platform Standing Status ---
            if (onPlatformThisFrame && player.currentPlatform !== onPlatformThisFrame) {
                 if (player.currentPlatform && player.currentPlatform !== 'ground') {
                     player.currentPlatform.isPlayerOn = false;
                     player.currentPlatform.standTimer = 0;
                 }
                 if (onPlatformThisFrame !== 'ground') {
                     player.currentPlatform = onPlatformThisFrame;
                     player.currentPlatform.isPlayerOn = true;
                     player.currentPlatform.standTimer = 0;
                 } else {
                     player.currentPlatform = null;
                 }
            }
            else if (!onPlatformThisFrame && player.currentPlatform && player.currentPlatform !== 'ground') {
                player.currentPlatform.isPlayerOn = false;
                player.currentPlatform.standTimer = 0;
                player.currentPlatform = null;
            }

            // --- Drawing ---
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw player
            ctx.fillStyle = 'red';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw platforms
            platforms.forEach(platform => {
                if (platform.isPlayerOn && !platform.isFalling) ctx.fillStyle = '#555';
                else if (platform.isFalling) ctx.fillStyle = '#AAA';
                else ctx.fillStyle = 'black';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

                // Draw Label
                if (platform.labelNumber !== null) {
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(platform.labelNumber, platform.x + platform.width / 2, platform.y + platform.height / 2);
                }
            });

            // Draw Score
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText('Score: ' + score, 10, 30);

            // Optional: Game Over check
             if (player.y > canvas.height + 100) {
                 ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 ctx.fillStyle = 'white';
                 ctx.font = '40px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
                 ctx.font = '20px Arial';
                 ctx.fillText('Final Score: ' + score, canvas.width / 2, canvas.height / 2 + 20);
                 ctx.fillText('Refresh to play again', canvas.width / 2, canvas.height / 2 + 50);
                 return;
             }

            requestAnimationFrame(updateGame);
        }

        updateGame(); // Start the game
    </script>
</body>
</html>